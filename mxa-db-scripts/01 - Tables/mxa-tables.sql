-- Tables

BEGIN 
	EXECUTE IMMEDIATE 'DROP TABLE CONTACTINFO CASCADE CONSTRAINTS'; 
	EXCEPTION WHEN OTHERS THEN NULL; 
END;
/

CREATE TABLE CONTACTINFO
(
  ID NUMBER NOT NULL,
  MESSAGEID NUMBER NOT NULL,
  TYPE VARCHAR2(10) NOT NULL,
  ADDRESS VARCHAR2(200) NOT NULL
, CONSTRAINT CONTACTINFO_PK PRIMARY KEY
  (
    ID
  )
  ENABLE
)
;

BEGIN 
	EXECUTE IMMEDIATE 'DROP TABLE LOG CASCADE CONSTRAINTS'; 
	EXCEPTION WHEN OTHERS THEN NULL; 
END;
/

CREATE TABLE LOG
(
  ID NUMBER NOT NULL,
  MESSAGEID NUMBER,
  TIME TIMESTAMP NOT NULL,
  LOGTYPE VARCHAR2(50) NOT NULL,
  LOGMSG VARCHAR2(1024) NOT NULL
, CONSTRAINT LOG_PK PRIMARY KEY
  (
    ID
  )
  ENABLE
)
;

BEGIN 
	EXECUTE IMMEDIATE 'DROP TABLE MESSAGE CASCADE CONSTRAINTS'; 
	EXCEPTION WHEN OTHERS THEN NULL; 
END;
/

CREATE TABLE MESSAGE
(
  ID NUMBER NOT NULL,
  MESSAGEKEY VARCHAR2(80) NOT NULL,
  SENDINGSYSTEM VARCHAR2(15) NOT NULL,
  BATCHSENDING NUMBER(1, 0) NOT NULL,
  DOMAIN VARCHAR2(10) NOT NULL,
  CASEDESCRIPTION VARCHAR2(50),
  CASEOFFICER VARCHAR2(50),
  PARTICIPANTID VARCHAR2(11) NOT NULL,
  MESSAGEREFERENCE VARCHAR2(40) NOT NULL,
  IDPROC VARCHAR2(40) NOT NULL,
  DUEDATE DATE,
  ALTINNARCHIVE VARCHAR2(50),
  MESSAGEHEADER VARCHAR2(128) NOT NULL,
  MESSAGESUMMARY VARCHAR2(512) NOT NULL,
  SENTALTINN NUMBER(1, 0) NOT NULL,
  SENTALTINNDATE TIMESTAMP,
  MSG_STATUS NUMBER(2, 0) NOT NULL,
  READDEADLINE DATE NOT NULL,
  OVERDUENOTICESENT NUMBER(1, 0) NOT NULL
, CONSTRAINT MESSAGE_PK PRIMARY KEY
  (
    ID
  )
  ENABLE
)
;

BEGIN 
	EXECUTE IMMEDIATE 'DROP TABLE KEYVALUES CASCADE CONSTRAINTS'; 
	EXCEPTION WHEN OTHERS THEN NULL; 
END;
/

CREATE TABLE KEYVALUES
(
  ID NUMBER NOT NULL,
  KEY VARCHAR2(20) NOT NULL,
  DATEVALUE DATE,
  NUMERICVALUE NUMBER,
  STRINGVALUE VARCHAR2(1020),
  DESCRIPTION VARCHAR2(255)
, CONSTRAINT KEYVALUES_PK PRIMARY KEY
  (
    ID
  )
  ENABLE
)
;

BEGIN 
	EXECUTE IMMEDIATE 'DROP TABLE ATTACHMENT CASCADE CONSTRAINTS'; 
	EXCEPTION WHEN OTHERS THEN NULL; 
END;
/

CREATE TABLE ATTACHMENT
(
  ID NUMBER NOT NULL,
  MESSAGEID NUMBER NOT NULL,
  ATTACHMENT CLOB NOT NULL,
  MIMETYPE VARCHAR2(255) NOT NULL,
  FILENAME VARCHAR2(50) NOT NULL,
  NAME VARCHAR2(50) NOT NULL
, CONSTRAINT ATTACHMENT_PK PRIMARY KEY
  (
    ID
  )
  ENABLE
)
;

ALTER TABLE CONTACTINFO
ADD CONSTRAINT CONTACTINFO_MESSAGE_FK1 FOREIGN KEY
(
  MESSAGEID
)
REFERENCES MESSAGE
(
  ID
)
 ENABLE
;

ALTER TABLE LOG
ADD CONSTRAINT LOG_MESSAGE_FK1 FOREIGN KEY
(
  MESSAGEID
)
REFERENCES MESSAGE
(
  ID
)
 ENABLE
;

ALTER TABLE ATTACHMENT
ADD CONSTRAINT ATTACHMENT_MESSAGE_FK1 FOREIGN KEY
(
  MESSAGEID
)
REFERENCES MESSAGE
(
  ID
)
 ENABLE
;

ALTER TABLE CONTACTINFO
ADD CONSTRAINT CTI_TYPE_CHK CHECK
(TYPE IN ('SMS', 'EMAIL'))
 ENABLE
;

ALTER TABLE MESSAGE
ADD CONSTRAINT MSG_BTS_CHK CHECK
(BATCHSENDING IN (0, 1))
 ENABLE
;

ALTER TABLE MESSAGE
ADD CONSTRAINT MSG_ONS_CHK CHECK
(OVERDUENOTICESENT IN (0, 1))
 ENABLE
;

ALTER TABLE MESSAGE
ADD CONSTRAINT MSG_SAL_CHK CHECK
(SENTALTINN IN (0, 1))
 ENABLE
;

COMMENT ON COLUMN ATTACHMENT.ATTACHMENT IS 'This is the base64  encoded attatchment'
;

CREATE INDEX CTI_MSG_IDX ON CONTACTINFO (MESSAGEID);

CREATE INDEX LOG_MSG_IDX ON LOG (MESSAGEID);

CREATE INDEX MSG_DMN_IDX ON MESSAGE (DOMAIN);

CREATE INDEX MSG_DUE_IDX ON MESSAGE (DUEDATE);

CREATE UNIQUE INDEX MSG_MSK_IDX ON MESSAGE (MESSAGEKEY);

CREATE UNIQUE INDEX MSG_MSR_IDX ON MESSAGE (MESSAGEREFERENCE);

CREATE INDEX MSG_MSTAT_IDX ON MESSAGE (MSG_STATUS);

CREATE INDEX MSG_PID_IDX ON MESSAGE (PARTICIPANTID);

CREATE INDEX MSG_SAD_IDX ON MESSAGE (SENTALTINNDATE);

CREATE INDEX MSG_SAL_IDX ON MESSAGE (SENTALTINN);

CREATE INDEX KEY_KEY_IDX ON KEYVALUES (KEY);

CREATE INDEX ATT_MSG_IDX ON ATTACHMENT (MESSAGEID);

BEGIN 
    EXECUTE IMMEDIATE 'DROP SEQUENCE CONTACTINFO_SEQ'; 
    EXCEPTION WHEN OTHERS THEN NULL; 
END;
/

CREATE SEQUENCE CONTACTINFO_SEQ;

BEGIN 
    EXECUTE IMMEDIATE 'DROP SEQUENCE MESSAGE_SEQ'; 
    EXCEPTION WHEN OTHERS THEN NULL; 
END;
/

CREATE SEQUENCE MESSAGE_SEQ;

BEGIN
    EXECUTE IMMEDIATE 'DROP SEQUENCE KEYVALUES_SEQ'; 
    EXCEPTION WHEN OTHERS THEN NULL; 
END;
/

CREATE SEQUENCE KEYVALUES_SEQ;

BEGIN
    EXECUTE IMMEDIATE 'DROP SEQUENCE LOG_SEQ'; 
    EXCEPTION WHEN OTHERS THEN NULL; 
END;
/

CREATE SEQUENCE LOG_SEQ;

BEGIN
    EXECUTE IMMEDIATE 'DROP SEQUENCE ATTACHMENT_SEQ'; 
    EXCEPTION WHEN OTHERS THEN NULL; 
END;
/

CREATE SEQUENCE ATTACHMENT_SEQ;

-- Quartz tables

BEGIN 
	EXECUTE IMMEDIATE 'DROP TABLE QRTZ_JOB_DETAILS CASCADE CONSTRAINTS'; 
	EXCEPTION WHEN OTHERS THEN NULL; 
END;
/

CREATE TABLE QRTZ_JOB_DETAILS
(
  JOB_NAME           VARCHAR2(200 BYTE)         NOT NULL,
  JOB_GROUP          VARCHAR2(200 BYTE)         NOT NULL,
  DESCRIPTION        VARCHAR2(250 BYTE),
  JOB_CLASS_NAME     VARCHAR2(250 BYTE)         NOT NULL,
  IS_DURABLE         VARCHAR2(1 BYTE)           NOT NULL,
  IS_VOLATILE        VARCHAR2(1 BYTE)           NOT NULL,
  IS_STATEFUL        VARCHAR2(1 BYTE)           NOT NULL,
  REQUESTS_RECOVERY  VARCHAR2(1 BYTE)           NOT NULL,
  JOB_DATA           BLOB
);

CREATE INDEX IDX_QRTZ_J_REQ_RECOVERY ON QRTZ_JOB_DETAILS
(REQUESTS_RECOVERY);

ALTER TABLE QRTZ_JOB_DETAILS ADD (
  PRIMARY KEY
 (JOB_NAME, JOB_GROUP));


BEGIN 
	EXECUTE IMMEDIATE 'DROP TABLE QRTZ_JOB_LISTENERS CASCADE CONSTRAINTS'; 
	EXCEPTION WHEN OTHERS THEN NULL; 
END;
/

CREATE TABLE QRTZ_JOB_LISTENERS
(
  JOB_NAME      VARCHAR2(200 BYTE)              NOT NULL,
  JOB_GROUP     VARCHAR2(200 BYTE)              NOT NULL,
  JOB_LISTENER  VARCHAR2(200 BYTE)              NOT NULL
);


ALTER TABLE QRTZ_JOB_LISTENERS ADD (
  PRIMARY KEY
 (JOB_NAME, JOB_GROUP, JOB_LISTENER));

    BEGIN 
	EXECUTE IMMEDIATE 'DROP TABLE QRTZ_TRIGGERS CASCADE CONSTRAINTS';
	EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE TABLE QRTZ_TRIGGERS
(
  TRIGGER_NAME    VARCHAR2(200 BYTE)            NOT NULL,
  TRIGGER_GROUP   VARCHAR2(200 BYTE)            NOT NULL,
  JOB_NAME        VARCHAR2(200 BYTE)            NOT NULL,
  JOB_GROUP       VARCHAR2(200 BYTE)            NOT NULL,
  IS_VOLATILE     VARCHAR2(1 BYTE)              NOT NULL,
  DESCRIPTION     VARCHAR2(250 BYTE),
  NEXT_FIRE_TIME  NUMBER(13),
  PREV_FIRE_TIME  NUMBER(13),
  PRIORITY        NUMBER(13),
  TRIGGER_STATE   VARCHAR2(16 BYTE)             NOT NULL,
  TRIGGER_TYPE    VARCHAR2(8 BYTE)              NOT NULL,
  START_TIME      NUMBER(13)                    NOT NULL,
  END_TIME        NUMBER(13),
  CALENDAR_NAME   VARCHAR2(200 BYTE),
  MISFIRE_INSTR   NUMBER(2),
  JOB_DATA        BLOB
);


CREATE INDEX IDX_QRTZ_T_NFT_ST ON QRTZ_TRIGGERS
(NEXT_FIRE_TIME, TRIGGER_STATE)
;

CREATE INDEX IDX_QRTZ_T_VOLATILE ON QRTZ_TRIGGERS
(IS_VOLATILE);

CREATE INDEX IDX_QRTZ_T_NEXT_FIRE_TIME ON QRTZ_TRIGGERS
(NEXT_FIRE_TIME);

CREATE INDEX IDX_QRTZ_T_STATE ON QRTZ_TRIGGERS
(TRIGGER_STATE);

CREATE INDEX IDX_QRTZ_T_NF_ST ON QRTZ_TRIGGERS
(TRIGGER_STATE, NEXT_FIRE_TIME);

ALTER TABLE QRTZ_TRIGGERS ADD (
  PRIMARY KEY
 (TRIGGER_NAME, TRIGGER_GROUP));

BEGIN 
	EXECUTE IMMEDIATE 'DROP TABLE QRTZ_SIMPLE_TRIGGERS CASCADE CONSTRAINTS'; 
	EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE TABLE QRTZ_SIMPLE_TRIGGERS
(
  TRIGGER_NAME     VARCHAR2(200 BYTE)           NOT NULL,
  TRIGGER_GROUP    VARCHAR2(200 BYTE)           NOT NULL,
  REPEAT_COUNT     NUMBER(7)                    NOT NULL,
  REPEAT_INTERVAL  NUMBER(12)                   NOT NULL,
  TIMES_TRIGGERED  NUMBER(7)                    NOT NULL
);


ALTER TABLE QRTZ_SIMPLE_TRIGGERS ADD (
  PRIMARY KEY
 (TRIGGER_NAME, TRIGGER_GROUP));

BEGIN 
	EXECUTE IMMEDIATE 'DROP TABLE QRTZ_CRON_TRIGGERS CASCADE CONSTRAINTS';
	EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE TABLE QRTZ_CRON_TRIGGERS
(
  TRIGGER_NAME     VARCHAR2(200 BYTE)           NOT NULL,
  TRIGGER_GROUP    VARCHAR2(200 BYTE)           NOT NULL,
  CRON_EXPRESSION  VARCHAR2(120 BYTE)           NOT NULL,
  TIME_ZONE_ID     VARCHAR2(80 BYTE)
);

ALTER TABLE QRTZ_CRON_TRIGGERS ADD (
  PRIMARY KEY
 (TRIGGER_NAME, TRIGGER_GROUP));

BEGIN 
	EXECUTE IMMEDIATE 'DROP TABLE QRTZ_BLOB_TRIGGERS CASCADE CONSTRAINTS';
	EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE TABLE QRTZ_BLOB_TRIGGERS
(
  TRIGGER_NAME   VARCHAR2(200 BYTE)             NOT NULL,
  TRIGGER_GROUP  VARCHAR2(200 BYTE)             NOT NULL,
  BLOB_DATA      BLOB
);

ALTER TABLE QRTZ_BLOB_TRIGGERS ADD (
  PRIMARY KEY
 (TRIGGER_NAME, TRIGGER_GROUP));
 
     BEGIN 
	EXECUTE IMMEDIATE 'DROP TABLE QRTZ_TRIGGER_LISTENERS CASCADE CONSTRAINTS';
	EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE TABLE QRTZ_TRIGGER_LISTENERS
(
  TRIGGER_NAME      VARCHAR2(200 BYTE)          NOT NULL,
  TRIGGER_GROUP     VARCHAR2(200 BYTE)          NOT NULL,
  TRIGGER_LISTENER  VARCHAR2(200 BYTE)          NOT NULL
);

ALTER TABLE QRTZ_TRIGGER_LISTENERS ADD (
  PRIMARY KEY
 (TRIGGER_NAME, TRIGGER_GROUP, TRIGGER_LISTENER));

 BEGIN 
	EXECUTE IMMEDIATE 'DROP TABLE QRTZ_CALENDARS CASCADE CONSTRAINTS'; 
	EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE TABLE QRTZ_CALENDARS
(
  CALENDAR_NAME  VARCHAR2(200 BYTE)             NOT NULL,
  CALENDAR       BLOB                           NOT NULL
);

ALTER TABLE QRTZ_CALENDARS ADD (
  PRIMARY KEY
 (CALENDAR_NAME));

BEGIN 
	EXECUTE IMMEDIATE 'DROP TABLE QRTZ_PAUSED_TRIGGER_GRPS CASCADE CONSTRAINTS'; 
	EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS
(
  TRIGGER_GROUP  VARCHAR2(200 BYTE)             NOT NULL
);

ALTER TABLE QRTZ_PAUSED_TRIGGER_GRPS ADD (
  PRIMARY KEY
 (TRIGGER_GROUP));

 BEGIN 
	EXECUTE IMMEDIATE 'DROP TABLE QRTZ_FIRED_TRIGGERS CASCADE CONSTRAINTS'; 
	EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE TABLE QRTZ_FIRED_TRIGGERS
(
  ENTRY_ID           VARCHAR2(95 BYTE)          NOT NULL,
  TRIGGER_NAME       VARCHAR2(200 BYTE)         NOT NULL,
  TRIGGER_GROUP      VARCHAR2(200 BYTE)         NOT NULL,
  IS_VOLATILE        VARCHAR2(1 BYTE)           NOT NULL,
  INSTANCE_NAME      VARCHAR2(200 BYTE)         NOT NULL,
  FIRED_TIME         NUMBER(13)                 NOT NULL,
  PRIORITY           NUMBER(13)                 NOT NULL,
  STATE              VARCHAR2(16 BYTE)          NOT NULL,
  JOB_NAME           VARCHAR2(200 BYTE),
  JOB_GROUP          VARCHAR2(200 BYTE),
  IS_STATEFUL        VARCHAR2(1 BYTE),
  REQUESTS_RECOVERY  VARCHAR2(1 BYTE)
);

CREATE INDEX IDX_QRTZ_FT_TRIG_N_G ON QRTZ_FIRED_TRIGGERS
(TRIGGER_NAME, TRIGGER_GROUP);

CREATE INDEX IDX_QRTZ_FT_TRIG_INST_NAME ON QRTZ_FIRED_TRIGGERS
(INSTANCE_NAME);

CREATE INDEX IDX_QRTZ_FT_JOB_NAME ON QRTZ_FIRED_TRIGGERS
(JOB_NAME);

CREATE INDEX IDX_QRTZ_FT_JOB_GROUP ON QRTZ_FIRED_TRIGGERS
(JOB_GROUP);

CREATE INDEX IDX_QRTZ_FT_TRIG_VOLATILE ON QRTZ_FIRED_TRIGGERS
(IS_VOLATILE);

CREATE INDEX IDX_QRTZ_FT_JOB_STATEFUL ON QRTZ_FIRED_TRIGGERS
(IS_STATEFUL);

CREATE INDEX IDX_QRTZ_FT_JOB_REQ_RECOVERY ON QRTZ_FIRED_TRIGGERS
(REQUESTS_RECOVERY);

CREATE INDEX IDX_QRTZ_FT_TRIG_NAME ON QRTZ_FIRED_TRIGGERS
(TRIGGER_NAME);

CREATE INDEX IDX_QRTZ_FT_TRIG_GROUP ON QRTZ_FIRED_TRIGGERS
(TRIGGER_GROUP);

ALTER TABLE QRTZ_FIRED_TRIGGERS ADD (
  PRIMARY KEY
 (ENTRY_ID));

BEGIN 
	EXECUTE IMMEDIATE 'DROP TABLE QRTZ_SCHEDULER_STATE CASCADE CONSTRAINTS'; 
	EXCEPTION WHEN OTHERS THEN NULL; 
END;
/

CREATE TABLE QRTZ_SCHEDULER_STATE
(
  INSTANCE_NAME      VARCHAR2(200 BYTE)         NOT NULL,
  LAST_CHECKIN_TIME  NUMBER(13)                 NOT NULL,
  CHECKIN_INTERVAL   NUMBER(13)                 NOT NULL
);
ALTER TABLE QRTZ_SCHEDULER_STATE ADD (
  PRIMARY KEY
 (INSTANCE_NAME));

BEGIN 
	EXECUTE IMMEDIATE 'DROP TABLE QRTZ_LOCKS CASCADE CONSTRAINTS'; 
	EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE TABLE QRTZ_LOCKS
(
  LOCK_NAME  VARCHAR2(40 BYTE)                  NOT NULL
);
ALTER TABLE QRTZ_LOCKS ADD (
  PRIMARY KEY
 (LOCK_NAME));

